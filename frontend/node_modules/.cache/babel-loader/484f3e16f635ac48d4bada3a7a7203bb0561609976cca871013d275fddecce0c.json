{"ast":null,"code":"var _ApiNeo4jService;\n// services/ApiNeo4jService.ts - COMPLETE with orphan removal functionality\nimport { transformHierarchicalOptions } from '../types/FitlerTypes';\nexport class ApiNeo4jService {\n  constructor() {\n    this.baseUrl = void 0;\n    this.regionDataCache = new Map();\n    this.filterOptionsCache = new Map();\n    this.baseUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';\n    console.log(`üîå ApiNeo4jService initialized with base URL: ${this.baseUrl}`);\n  }\n  static getInstance() {\n    if (!ApiNeo4jService.instance) {\n      ApiNeo4jService.instance = new ApiNeo4jService();\n    }\n    return ApiNeo4jService.instance;\n  }\n  async testConnection() {\n    try {\n      const response = await fetch(`${this.baseUrl}/health`);\n      const data = await response.json();\n      console.log('üîç API Health Check:', data);\n      return data.status === 'healthy' && data.database_connected;\n    } catch (error) {\n      console.error('‚ùå API connection test failed:', error);\n      return false;\n    }\n  }\n  async getDatabaseStats() {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/v1/hierarchical/health`);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      const stats = await response.json();\n      console.log('üìä Hierarchical service stats retrieved:', stats);\n      return stats;\n    } catch (error) {\n      console.error('‚ùå Failed to get database stats:', error);\n      // Fallback to regular stats endpoint\n      try {\n        const response = await fetch(`${this.baseUrl}/api/v1/graph/stats`);\n        if (response.ok) {\n          return await response.json();\n        }\n      } catch (fallbackError) {\n        console.error('‚ùå Fallback stats also failed:', fallbackError);\n      }\n      throw error;\n    }\n  }\n  async getAvailableRegions() {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/v1/hierarchical/regions`);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      const data = await response.json();\n      console.log('üåç Available regions:', data.regions);\n      return data.regions || ['NAI', 'EMEA', 'APAC'];\n    } catch (error) {\n      console.error('‚ùå Failed to get available regions:', error);\n      return ['NAI', 'EMEA', 'APAC'];\n    }\n  }\n  async getRegionData(regions = ['NAI']) {\n    console.log(`üåç Loading data for regions using hierarchical endpoint: ${regions.join(', ')}`);\n    try {\n      const region = regions[0];\n      const cacheKey = regions.sort().join(',');\n      if (this.regionDataCache.has(cacheKey)) {\n        console.log(`üìã Using cached data for ${cacheKey}`);\n        return this.regionDataCache.get(cacheKey);\n      }\n      const response = await fetch(`${this.baseUrl}/api/v1/hierarchical/region/${region}/complete`);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      const hierarchicalData = await response.json();\n      if (!hierarchicalData.success || !hierarchicalData.data) {\n        throw new Error(hierarchicalData.error || 'Failed to get hierarchical data');\n      }\n      console.log(`‚úÖ Retrieved hierarchical data for ${region}:`, {\n        nodes: hierarchicalData.data.graph_data.nodes.length,\n        relationships: hierarchicalData.data.graph_data.relationships.length,\n        filterOptions: hierarchicalData.data.statistics.total_filter_options\n      });\n      const transformedData = {\n        nodes: hierarchicalData.data.graph_data.nodes,\n        relationships: hierarchicalData.data.graph_data.relationships,\n        metadata: {\n          region: hierarchicalData.data.region,\n          statistics: hierarchicalData.data.statistics,\n          source: 'hierarchical_complete_workflow'\n        }\n      };\n      this.filterOptionsCache.set(region, transformHierarchicalOptions(hierarchicalData.data.filter_options || {}));\n      this.regionDataCache.set(cacheKey, transformedData);\n      return transformedData;\n    } catch (error) {\n      console.error('‚ùå Failed to fetch region data:', error);\n      throw new Error(`Failed to fetch region data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n  async changeRegion(newRegion, currentRegion) {\n    console.log(`üîÑ Changing region from ${currentRegion || 'unknown'} to ${newRegion}`);\n    try {\n      const response = await fetch(`${this.baseUrl}/api/v1/hierarchical/region/change/${newRegion}?current_region=${currentRegion || ''}`, {\n        method: 'PUT'\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      const hierarchicalData = await response.json();\n      if (!hierarchicalData.success || !hierarchicalData.data) {\n        throw new Error(hierarchicalData.error || 'Failed to change region');\n      }\n      console.log(`‚úÖ Region changed to ${newRegion}:`, {\n        nodes: hierarchicalData.data.graph_data.nodes.length,\n        relationships: hierarchicalData.data.graph_data.relationships.length\n      });\n      this.regionDataCache.clear();\n      const transformedData = {\n        nodes: hierarchicalData.data.graph_data.nodes,\n        relationships: hierarchicalData.data.graph_data.relationships,\n        metadata: {\n          region: hierarchicalData.data.region,\n          statistics: hierarchicalData.data.statistics,\n          source: 'hierarchical_region_change'\n        }\n      };\n      this.filterOptionsCache.set(newRegion, transformHierarchicalOptions(hierarchicalData.data.filter_options || {}));\n      this.regionDataCache.set(newRegion, transformedData);\n      return transformedData;\n    } catch (error) {\n      console.error('‚ùå Failed to change region:', error);\n      throw new Error(`Failed to change region: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n  async getFilterOptionsFromData(data) {\n    console.log('üìä Getting filter options from hierarchical data...');\n    try {\n      var _data$metadata;\n      const region = (_data$metadata = data.metadata) === null || _data$metadata === void 0 ? void 0 : _data$metadata.region;\n      if (region && this.filterOptionsCache.has(region)) {\n        console.log(`üìã Using cached filter options for ${region}`);\n        return this.filterOptionsCache.get(region);\n      }\n      return this.extractFilterOptionsFromData(data);\n    } catch (error) {\n      console.error('‚ùå Failed to get filter options:', error);\n      return this.getEmptyFilterOptions();\n    }\n  }\n\n  // üÜï ENHANCED: Main filtering method with orphan removal\n  async applyFiltersToData(data, filters) {\n    var _data$nodes, _data$relationships, _filters$clientAdviso, _filters$consultantAd, _filters$clientAdviso2, _filters$consultantAd2, _data$nodes2, _filteredData$nodes, _filters$clientAdviso3, _filters$consultantAd3;\n    console.log('üîç Enhanced applyFiltersToData with advisor filtering:', {\n      nodeCount: ((_data$nodes = data.nodes) === null || _data$nodes === void 0 ? void 0 : _data$nodes.length) || 0,\n      relationshipCount: ((_data$relationships = data.relationships) === null || _data$relationships === void 0 ? void 0 : _data$relationships.length) || 0,\n      clientAdvisorIds: ((_filters$clientAdviso = filters.clientAdvisorIds) === null || _filters$clientAdviso === void 0 ? void 0 : _filters$clientAdviso.length) || 0,\n      consultantAdvisorIds: ((_filters$consultantAd = filters.consultantAdvisorIds) === null || _filters$consultantAd === void 0 ? void 0 : _filters$consultantAd.length) || 0\n    });\n\n    // üÜï STEP 1: Apply advisor filters FIRST (most selective)\n    let filteredData = {\n      ...data\n    };\n    if ((_filters$clientAdviso2 = filters.clientAdvisorIds) !== null && _filters$clientAdviso2 !== void 0 && _filters$clientAdviso2.length || (_filters$consultantAd2 = filters.consultantAdvisorIds) !== null && _filters$consultantAd2 !== void 0 && _filters$consultantAd2.length) {\n      console.log('üë• Applying advisor filters first...');\n      filteredData = this.applyAdvisorFilters(filteredData, filters);\n    }\n\n    // üÜï STEP 2: Apply existing filtering logic\n    filteredData = this.applyFiltersLocallyWithOrphanRemoval(filteredData, filters);\n    console.log('‚úÖ Enhanced filtering complete:', {\n      originalNodes: ((_data$nodes2 = data.nodes) === null || _data$nodes2 === void 0 ? void 0 : _data$nodes2.length) || 0,\n      filteredNodes: ((_filteredData$nodes = filteredData.nodes) === null || _filteredData$nodes === void 0 ? void 0 : _filteredData$nodes.length) || 0,\n      advisorFilterApplied: !!((_filters$clientAdviso3 = filters.clientAdvisorIds) !== null && _filters$clientAdviso3 !== void 0 && _filters$clientAdviso3.length || (_filters$consultantAd3 = filters.consultantAdvisorIds) !== null && _filters$consultantAd3 !== void 0 && _filters$consultantAd3.length)\n    });\n    return filteredData;\n  }\n\n  // üîß FIXED: Enhanced advisor filtering with CORRECT relationship directions\n  applyAdvisorFilters(data, filters) {\n    const nodes = data.nodes || [];\n    const relationships = data.relationships || [];\n    const clientAdvisorIds = filters.clientAdvisorIds || [];\n    const consultantAdvisorIds = filters.consultantAdvisorIds || [];\n    console.log('üë• Applying FIXED advisor filters with correct relationship directions:', {\n      clientAdvisors: clientAdvisorIds.length,\n      consultantAdvisors: consultantAdvisorIds.length,\n      totalNodes: nodes.length,\n      totalRelationships: relationships.length\n    });\n    if (!clientAdvisorIds.length && !consultantAdvisorIds.length) {\n      return data;\n    }\n\n    // Step 1: Find anchor nodes (companies/consultants matching advisor criteria)\n    const anchorNodeIds = new Set();\n\n    // Client Advisor filtering (Company PCA/ACA) - Find matching companies\n    if (clientAdvisorIds.length > 0) {\n      console.log('üè¢ Finding companies with Client Advisors:', clientAdvisorIds);\n      nodes.forEach(node => {\n        var _node$labels;\n        if ((_node$labels = node.labels) !== null && _node$labels !== void 0 && _node$labels.includes('COMPANY')) {\n          const props = node.properties || {};\n          const companyPca = props.pca || '';\n          const companyAca = props.aca || '';\n          if (clientAdvisorIds.includes(companyPca) || clientAdvisorIds.includes(companyAca)) {\n            anchorNodeIds.add(node.id);\n            console.log(`   ‚úÖ Company \"${props.name || node.id}\" matches (PCA: ${companyPca}, ACA: ${companyAca})`);\n          }\n        }\n      });\n    }\n\n    // Consultant Advisor filtering (Consultant PCA/Advisor) - Find matching consultants\n    if (consultantAdvisorIds.length > 0) {\n      console.log('üë®‚Äçüíº Finding consultants with Consultant Advisors:', consultantAdvisorIds);\n      nodes.forEach(node => {\n        var _node$labels2;\n        if ((_node$labels2 = node.labels) !== null && _node$labels2 !== void 0 && _node$labels2.includes('CONSULTANT')) {\n          const props = node.properties || {};\n          const consultantPca = props.pca || '';\n          const consultantAdvisor = props.consultant_advisor || '';\n          if (consultantAdvisorIds.includes(consultantPca) || consultantAdvisorIds.includes(consultantAdvisor)) {\n            anchorNodeIds.add(node.id);\n            console.log(`   ‚úÖ Consultant \"${props.name || node.id}\" matches (PCA: ${consultantPca}, Advisor: ${consultantAdvisor})`);\n          }\n        }\n      });\n    }\n    console.log(`üìä Found ${anchorNodeIds.size} anchor nodes (companies/consultants)`);\n    if (anchorNodeIds.size === 0) {\n      console.log('‚ùå No matching advisor nodes found');\n      return {\n        ...data,\n        nodes: [],\n        relationships: []\n      };\n    }\n\n    // Step 2: CORRECTED - Build complete subgraph following correct relationship paths\n    const relevantNodeIds = new Set(anchorNodeIds);\n\n    // üîß FIXED: Specific path expansion based on anchor type\n    if (clientAdvisorIds.length > 0) {\n      console.log('üè¢ Client Advisor path: Company ‚Üí Field Consultant ‚Üí Consultant ‚Üí Products');\n      this.expandFromCompanies(relevantNodeIds, nodes, relationships);\n    }\n    if (consultantAdvisorIds.length > 0) {\n      console.log('üë®‚Äçüíº Consultant Advisor path: Consultant ‚Üí Field Consultant ‚Üí Company ‚Üí Products');\n      this.expandFromConsultants(relevantNodeIds, nodes, relationships);\n    }\n    console.log(`‚úÖ Final expansion: ${relevantNodeIds.size} total nodes in subgraph`);\n\n    // Step 3: Filter nodes and relationships\n    const filteredNodes = nodes.filter(node => relevantNodeIds.has(node.id));\n    const filteredRelationships = relationships.filter(rel => relevantNodeIds.has(rel.start_node_id) && relevantNodeIds.has(rel.end_node_id));\n\n    // Step 4: Debug output - show what types of nodes we got\n    const nodeTypeCounts = {};\n    filteredNodes.forEach(node => {\n      var _node$labels3;\n      (_node$labels3 = node.labels) === null || _node$labels3 === void 0 ? void 0 : _node$labels3.forEach(label => {\n        nodeTypeCounts[label] = (nodeTypeCounts[label] || 0) + 1;\n      });\n    });\n    console.log('üìà Filtered subgraph composition:', nodeTypeCounts);\n    console.log(`‚úÖ Advisor filtering result: ${filteredNodes.length} nodes, ${filteredRelationships.length} relationships`);\n    return {\n      ...data,\n      nodes: filteredNodes,\n      relationships: filteredRelationships,\n      metadata: {\n        ...data.metadata,\n        advisor_filter_applied: true,\n        client_advisors_selected: clientAdvisorIds.length,\n        consultant_advisors_selected: consultantAdvisorIds.length,\n        original_node_count: nodes.length,\n        filtered_node_count: filteredNodes.length,\n        anchor_nodes_found: anchorNodeIds.size,\n        subgraph_composition: nodeTypeCounts\n      }\n    };\n  }\n\n  // üÜï Helper: Expand from companies following: Company ‚Üê Field Consultant ‚Üê Consultant\n  expandFromCompanies(nodeIds, nodes, relationships) {\n    const companies = Array.from(nodeIds).filter(id => {\n      var _node$labels4;\n      const node = nodes.find(n => n.id === id);\n      return node === null || node === void 0 ? void 0 : (_node$labels4 = node.labels) === null || _node$labels4 === void 0 ? void 0 : _node$labels4.includes('COMPANY');\n    });\n    console.log(`üè¢ Expanding from ${companies.length} companies...`);\n\n    // Step 1: Company ‚Üí Products (OWNS relationship)\n    relationships.forEach(rel => {\n      if (rel.type === 'OWNS' && companies.includes(rel.start_node_id)) {\n        var _product$properties;\n        nodeIds.add(rel.end_node_id); // Add product\n        const product = nodes.find(n => n.id === rel.end_node_id);\n        console.log(`   üì¶ Added Product: ${(product === null || product === void 0 ? void 0 : (_product$properties = product.properties) === null || _product$properties === void 0 ? void 0 : _product$properties.name) || rel.end_node_id}`);\n      }\n    });\n\n    // Step 2: Company ‚Üê Field Consultant (COVERS relationship: FC -COVERS-> Company)\n    const fieldConsultants = new Set();\n    relationships.forEach(rel => {\n      if (rel.type === 'COVERS' && companies.includes(rel.end_node_id)) {\n        var _fc$properties;\n        nodeIds.add(rel.start_node_id); // Add field consultant\n        fieldConsultants.add(rel.start_node_id);\n        const fc = nodes.find(n => n.id === rel.start_node_id);\n        console.log(`   üë• Added Field Consultant: ${(fc === null || fc === void 0 ? void 0 : (_fc$properties = fc.properties) === null || _fc$properties === void 0 ? void 0 : _fc$properties.name) || rel.start_node_id}`);\n      }\n    });\n\n    // Step 3: Field Consultant ‚Üê Consultant (EMPLOYS relationship: Consultant -EMPLOYS-> FC)\n    relationships.forEach(rel => {\n      if (rel.type === 'EMPLOYS' && fieldConsultants.has(rel.end_node_id)) {\n        var _consultant$propertie;\n        nodeIds.add(rel.start_node_id); // Add consultant\n        const consultant = nodes.find(n => n.id === rel.start_node_id);\n        console.log(`   üë®‚Äçüíº Added Consultant: ${(consultant === null || consultant === void 0 ? void 0 : (_consultant$propertie = consultant.properties) === null || _consultant$propertie === void 0 ? void 0 : _consultant$propertie.name) || rel.start_node_id}`);\n      }\n    });\n  }\n\n  // üÜï Helper: Expand from consultants following: Consultant ‚Üí Field Consultant ‚Üí Company ‚Üí Products\n  expandFromConsultants(nodeIds, nodes, relationships) {\n    const consultants = Array.from(nodeIds).filter(id => {\n      var _node$labels5;\n      const node = nodes.find(n => n.id === id);\n      return node === null || node === void 0 ? void 0 : (_node$labels5 = node.labels) === null || _node$labels5 === void 0 ? void 0 : _node$labels5.includes('CONSULTANT');\n    });\n    console.log(`üë®‚Äçüíº Expanding from ${consultants.length} consultants...`);\n\n    // Step 1: Consultant ‚Üí Field Consultant (EMPLOYS relationship)\n    const fieldConsultants = new Set();\n    relationships.forEach(rel => {\n      if (rel.type === 'EMPLOYS' && consultants.includes(rel.start_node_id)) {\n        var _fc$properties2;\n        nodeIds.add(rel.end_node_id); // Add field consultant\n        fieldConsultants.add(rel.end_node_id);\n        const fc = nodes.find(n => n.id === rel.end_node_id);\n        console.log(`   üë• Added Field Consultant: ${(fc === null || fc === void 0 ? void 0 : (_fc$properties2 = fc.properties) === null || _fc$properties2 === void 0 ? void 0 : _fc$properties2.name) || rel.end_node_id}`);\n      }\n    });\n\n    // Step 2: Field Consultant ‚Üí Company (COVERS relationship)\n    const companies = new Set();\n    relationships.forEach(rel => {\n      if (rel.type === 'COVERS' && fieldConsultants.has(rel.start_node_id)) {\n        var _company$properties;\n        nodeIds.add(rel.end_node_id); // Add company\n        companies.add(rel.end_node_id);\n        const company = nodes.find(n => n.id === rel.end_node_id);\n        console.log(`   üè¢ Added Company: ${(company === null || company === void 0 ? void 0 : (_company$properties = company.properties) === null || _company$properties === void 0 ? void 0 : _company$properties.name) || rel.end_node_id}`);\n      }\n    });\n\n    // Step 3: Company ‚Üí Products (OWNS relationship)\n    relationships.forEach(rel => {\n      if (rel.type === 'OWNS' && companies.has(rel.start_node_id)) {\n        var _product$properties2;\n        nodeIds.add(rel.end_node_id); // Add product\n        const product = nodes.find(n => n.id === rel.end_node_id);\n        console.log(`   üì¶ Added Product: ${(product === null || product === void 0 ? void 0 : (_product$properties2 = product.properties) === null || _product$properties2 === void 0 ? void 0 : _product$properties2.name) || rel.end_node_id}`);\n      }\n    });\n  }\n\n  // üÜï ENHANCED: Core filtering logic with smart orphan removal\n  applyFiltersLocallyWithOrphanRemoval(data, filters) {\n    let filteredNodes = [...data.nodes];\n    let filteredRelationships = [...data.relationships];\n    console.log(`üîç Starting with ${filteredNodes.length} nodes, ${filteredRelationships.length} relationships`);\n\n    // Step 1: Apply node type filters\n    if (filters.nodeTypes && filters.nodeTypes.length > 0) {\n      filteredNodes = filteredNodes.filter(node => filters.nodeTypes.some(type => node.labels.includes(type)));\n      console.log(`üìä After node type filter: ${filteredNodes.length} nodes`);\n    }\n\n    // Step 2: Apply geographic filters\n    if (filters.sales_regions && filters.sales_regions.length > 0) {\n      filteredNodes = filteredNodes.filter(node => !node.properties.sales_region || filters.sales_regions.includes(node.properties.sales_region));\n      console.log(`üåç After sales region filter: ${filteredNodes.length} nodes`);\n    }\n    if (filters.channels && filters.channels.length > 0) {\n      filteredNodes = filteredNodes.filter(node => !node.properties.channel || filters.channels.includes(node.properties.channel));\n      console.log(`üì° After channel filter: ${filteredNodes.length} nodes`);\n    }\n\n    // Step 3: Apply entity-specific filters (these create focused subgraphs)\n    let focusedFiltering = false;\n\n    // üéØ CONSULTANT FILTERING with connected subgraph\n    if (filters.consultantIds && filters.consultantIds.length > 0) {\n      console.log(`üëî Filtering to specific consultants: ${filters.consultantIds.join(', ')}`);\n      focusedFiltering = true;\n      const connectedNodeIds = this.getConsultantSubgraph(filteredNodes, filteredRelationships, filters.consultantIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After consultant subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n\n    // üéØ COMPANY FILTERING with connected subgraph\n    if (filters.clientIds && filters.clientIds.length > 0) {\n      console.log(`üè¢ Filtering to specific companies: ${filters.clientIds.join(', ')}`);\n      focusedFiltering = true;\n      const connectedNodeIds = this.getCompanySubgraph(filteredNodes, filteredRelationships, filters.clientIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After company subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n\n    // üéØ FIELD CONSULTANT FILTERING with connected subgraph\n    if (filters.fieldConsultantIds && filters.fieldConsultantIds.length > 0) {\n      console.log(`üìã Filtering to specific field consultants: ${filters.fieldConsultantIds.join(', ')}`);\n      focusedFiltering = true;\n      const connectedNodeIds = this.getFieldConsultantSubgraph(filteredNodes, filteredRelationships, filters.fieldConsultantIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After field consultant subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n\n    // üéØ PRODUCT FILTERING with connected subgraph\n    if (filters.productIds && filters.productIds.length > 0) {\n      console.log(`üè¶ Filtering to specific products: ${filters.productIds.join(', ')}`);\n      focusedFiltering = true;\n      const connectedNodeIds = this.getProductSubgraph(filteredNodes, filteredRelationships, filters.productIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After product subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n\n    // Step 4: Filter relationships based on remaining nodes\n    const nodeIds = new Set(filteredNodes.map(n => n.id));\n    filteredRelationships = filteredRelationships.filter(rel => nodeIds.has(rel.start_node_id) && nodeIds.has(rel.end_node_id));\n    console.log(`üîó After node filtering, relationships: ${filteredRelationships.length}`);\n\n    // Step 5: Apply relationship-specific filters\n    if (filters.mandateStatuses && filters.mandateStatuses.length > 0) {\n      filteredRelationships = filteredRelationships.filter(rel => rel.type !== 'OWNS' || !rel.properties.mandate_status || filters.mandateStatuses.includes(rel.properties.mandate_status));\n      console.log(`üìã After mandate status filter: ${filteredRelationships.length} relationships`);\n    }\n    if (filters.influenceLevels && filters.influenceLevels.length > 0) {\n      filteredRelationships = filteredRelationships.filter(rel => rel.type !== 'COVERS' || !rel.properties.level_of_influence || filters.influenceLevels.includes(String(rel.properties.level_of_influence)));\n      console.log(`‚≠ê After influence level filter: ${filteredRelationships.length} relationships`);\n    }\n    // üÜï NEW: INCUMBENT PRODUCT FILTERING with connected subgraph\n    if (filters.incumbentProductIds && filters.incumbentProductIds.length > 0) {\n      console.log(`üéØ Filtering to specific incumbent products: ${filters.incumbentProductIds.join(', ')}`);\n      focusedFiltering = true;\n      const connectedNodeIds = this.getIncumbentProductSubgraph(filteredNodes, filteredRelationships, filters.incumbentProductIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After incumbent product subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n    console.log(`üîó After node filtering, relationships: ${filteredRelationships.length}`);\n    // Step 6: Final orphan removal (unless we did focused filtering)\n    if (!focusedFiltering && !filters.showInactive) {\n      const connectedNodeIds = new Set([...filteredRelationships.map(r => r.start_node_id), ...filteredRelationships.map(r => r.end_node_id)]);\n      const beforeCount = filteredNodes.length;\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üßπ Removed ${beforeCount - filteredNodes.length} orphaned nodes (showInactive=false)`);\n    }\n    const result = {\n      nodes: filteredNodes,\n      relationships: filteredRelationships,\n      metadata: {\n        originalNodeCount: data.nodes.length,\n        originalRelationshipCount: data.relationships.length,\n        filteredNodeCount: filteredNodes.length,\n        filteredRelationshipCount: filteredRelationships.length,\n        filtersApplied: filters,\n        focusedFiltering: focusedFiltering\n      }\n    };\n    console.log(`‚úÖ Final result: ${result.nodes.length} nodes, ${result.relationships.length} relationships`);\n    console.log(`üìä Filtering mode: ${focusedFiltering ? 'Focused Subgraph' : 'General Filtering'}`);\n    return result;\n  }\n\n  // üÜï Helper method: Get consultant and connected subgraph\n  getConsultantSubgraph(nodes, relationships, consultantNames) {\n    const connectedNodeIds = new Set();\n\n    // Find selected consultants\n    const selectedConsultants = nodes.filter(node => node.labels.includes('CONSULTANT') && consultantNames.includes(node.properties.name));\n\n    // Add selected consultants\n    selectedConsultants.forEach(consultant => {\n      connectedNodeIds.add(consultant.id);\n      console.log(`üéØ Selected consultant: ${consultant.properties.name} (${consultant.id})`);\n    });\n\n    // Find field consultants employed by selected consultants\n    const employmentEdges = relationships.filter(rel => rel.type === 'EMPLOYS' && selectedConsultants.some(c => c.id === rel.start_node_id));\n    employmentEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const fieldConsultant = nodes.find(n => n.id === edge.end_node_id);\n      console.log(`  üìã Field consultant: ${fieldConsultant === null || fieldConsultant === void 0 ? void 0 : fieldConsultant.properties.name} (${edge.end_node_id})`);\n    });\n\n    // Find companies covered by these field consultants\n    const coverageEdges = relationships.filter(rel => rel.type === 'COVERS' && connectedNodeIds.has(rel.start_node_id));\n    coverageEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const company = nodes.find(n => n.id === edge.end_node_id);\n      console.log(`    üè¢ Company: ${company === null || company === void 0 ? void 0 : company.properties.name} (${edge.end_node_id})`);\n    });\n\n    // Find products owned by these companies (standard path)\n    const ownershipEdges = relationships.filter(rel => rel.type === 'OWNS' && connectedNodeIds.has(rel.start_node_id));\n    ownershipEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const product = nodes.find(n => n.id === edge.end_node_id);\n\n      // Check if this is an INCUMBENT_PRODUCT or regular PRODUCT\n      if (product !== null && product !== void 0 && product.labels.includes('INCUMBENT_PRODUCT')) {\n        console.log(`      üéØ Incumbent Product: ${product === null || product === void 0 ? void 0 : product.properties.name} (${edge.end_node_id})`);\n\n        // üÜï NEW: Find products recommended by this incumbent product via BI_RECOMMENDS\n        const recommendationEdges = relationships.filter(rel => rel.type === 'BI_RECOMMENDS' && rel.start_node_id === edge.end_node_id);\n        recommendationEdges.forEach(recEdge => {\n          connectedNodeIds.add(recEdge.end_node_id);\n          const recommendedProduct = nodes.find(n => n.id === recEdge.end_node_id);\n          console.log(`        üì¶ ‚Üí Recommended Product: ${recommendedProduct === null || recommendedProduct === void 0 ? void 0 : recommendedProduct.properties.name} (${recEdge.end_node_id})`);\n        });\n      } else if (product !== null && product !== void 0 && product.labels.includes('PRODUCT')) {\n        console.log(`      üì¶ Product: ${product === null || product === void 0 ? void 0 : product.properties.name} (${edge.end_node_id})`);\n      }\n    });\n    return connectedNodeIds;\n  }\n\n  // üÜï Helper method: Get company and connected subgraph\n  getCompanySubgraph(nodes, relationships, companyNames) {\n    const connectedNodeIds = new Set();\n\n    // Find selected companies\n    const selectedCompanies = nodes.filter(node => node.labels.includes('COMPANY') && companyNames.includes(node.properties.name));\n\n    // Add selected companies\n    selectedCompanies.forEach(company => {\n      connectedNodeIds.add(company.id);\n      console.log(`üéØ Selected company: ${company.properties.name} (${company.id})`);\n    });\n\n    // Find field consultants covering these companies\n    const coverageEdges = relationships.filter(rel => rel.type === 'COVERS' && selectedCompanies.some(c => c.id === rel.end_node_id));\n    coverageEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const fieldConsultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`  üìã Field consultant: ${fieldConsultant === null || fieldConsultant === void 0 ? void 0 : fieldConsultant.properties.name} (${edge.start_node_id})`);\n    });\n\n    // Find consultants employing these field consultants\n    const employmentEdges = relationships.filter(rel => rel.type === 'EMPLOYS' && connectedNodeIds.has(rel.end_node_id));\n    employmentEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const consultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`üë®‚Äçüíº Consultant: ${consultant === null || consultant === void 0 ? void 0 : consultant.properties.name} (${edge.start_node_id})`);\n    });\n\n    // Find products owned by selected companies\n    const ownershipEdges = relationships.filter(rel => rel.type === 'OWNS' && selectedCompanies.some(c => c.id === rel.start_node_id));\n    ownershipEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const product = nodes.find(n => n.id === edge.end_node_id);\n\n      // Check if this is an INCUMBENT_PRODUCT or regular PRODUCT\n      if (product !== null && product !== void 0 && product.labels.includes('INCUMBENT_PRODUCT')) {\n        console.log(`  üéØ Incumbent Product: ${product === null || product === void 0 ? void 0 : product.properties.name} (${edge.end_node_id})`);\n\n        // üÜï NEW: Find products recommended by this incumbent product via BI_RECOMMENDS\n        const recommendationEdges = relationships.filter(rel => rel.type === 'BI_RECOMMENDS' && rel.start_node_id === edge.end_node_id);\n        recommendationEdges.forEach(recEdge => {\n          connectedNodeIds.add(recEdge.end_node_id);\n          const recommendedProduct = nodes.find(n => n.id === recEdge.end_node_id);\n          console.log(`    üì¶ ‚Üí Recommended Product: ${recommendedProduct === null || recommendedProduct === void 0 ? void 0 : recommendedProduct.properties.name} (${recEdge.end_node_id})`);\n        });\n      } else if (product !== null && product !== void 0 && product.labels.includes('PRODUCT')) {\n        console.log(`  üì¶ Product: ${product === null || product === void 0 ? void 0 : product.properties.name} (${edge.end_node_id})`);\n      }\n    });\n    return connectedNodeIds;\n  }\n\n  // üÜï Helper method: Get field consultant and connected subgraph\n  getFieldConsultantSubgraph(nodes, relationships, fieldConsultantNames) {\n    const connectedNodeIds = new Set();\n    const selectedFieldConsultants = nodes.filter(node => node.labels.includes('FIELD_CONSULTANT') && fieldConsultantNames.includes(node.properties.name));\n\n    // Add selected field consultants\n    selectedFieldConsultants.forEach(fc => {\n      connectedNodeIds.add(fc.id);\n      console.log(`üéØ Selected field consultant: ${fc.properties.name} (${fc.id})`);\n    });\n\n    // Find their parent consultants\n    const employmentEdges = relationships.filter(rel => rel.type === 'EMPLOYS' && selectedFieldConsultants.some(fc => fc.id === rel.end_node_id));\n    employmentEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const consultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`üë®‚Äçüíº Consultant: ${consultant === null || consultant === void 0 ? void 0 : consultant.properties.name} (${edge.start_node_id})`);\n    });\n\n    // Find companies covered by selected field consultants\n    const coverageEdges = relationships.filter(rel => rel.type === 'COVERS' && selectedFieldConsultants.some(fc => fc.id === rel.start_node_id));\n    coverageEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const company = nodes.find(n => n.id === edge.end_node_id);\n      console.log(`  üè¢ Company: ${company === null || company === void 0 ? void 0 : company.properties.name} (${edge.end_node_id})`);\n    });\n\n    // Find products owned by covered companies\n    const companies = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node === null || node === void 0 ? void 0 : node.labels.includes('COMPANY');\n    });\n    const ownershipEdges = relationships.filter(rel => rel.type === 'OWNS' && companies.includes(rel.start_node_id));\n    ownershipEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const product = nodes.find(n => n.id === edge.end_node_id);\n\n      // üîß NEW: Check if this is an INCUMBENT_PRODUCT or regular PRODUCT\n      if (product !== null && product !== void 0 && product.labels.includes('INCUMBENT_PRODUCT')) {\n        console.log(`    üéØ Incumbent Product: ${product === null || product === void 0 ? void 0 : product.properties.name} (${edge.end_node_id})`);\n\n        // üÜï NEW: Find products recommended by this incumbent product via BI_RECOMMENDS\n        const recommendationEdges = relationships.filter(rel => rel.type === 'BI_RECOMMENDS' && rel.start_node_id === edge.end_node_id);\n        recommendationEdges.forEach(recEdge => {\n          connectedNodeIds.add(recEdge.end_node_id);\n          const recommendedProduct = nodes.find(n => n.id === recEdge.end_node_id);\n          console.log(`      üì¶ ‚Üí Recommended Product: ${recommendedProduct === null || recommendedProduct === void 0 ? void 0 : recommendedProduct.properties.name} (${recEdge.end_node_id})`);\n        });\n      } else if (product !== null && product !== void 0 && product.labels.includes('PRODUCT')) {\n        console.log(`    üì¶ Product: ${product === null || product === void 0 ? void 0 : product.properties.name} (${edge.end_node_id})`);\n      }\n    });\n    return connectedNodeIds;\n  }\n\n  // üÜï Helper method: Get product and connected subgraph\n  getProductSubgraph(nodes, relationships, productNames) {\n    const connectedNodeIds = new Set();\n    const selectedProducts = nodes.filter(node => (node.labels.includes('PRODUCT') || node.labels.includes('INCUMBENT_PRODUCT')) && productNames.includes(node.properties.name));\n\n    // Add selected products\n    selectedProducts.forEach(product => {\n      connectedNodeIds.add(product.id);\n      console.log(`üéØ Selected product: ${product.properties.name} (${product.id})`);\n    });\n\n    // üÜï NEW: Handle BI_RECOMMENDS relationships for both directions\n\n    // Find incumbent products that recommend selected products (reverse BI_RECOMMENDS)\n    const reverseRecommendationEdges = relationships.filter(rel => rel.type === 'BI_RECOMMENDS' && selectedProducts.some(p => p.id === rel.end_node_id));\n    reverseRecommendationEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const incumbentProduct = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`  üéØ ‚Üê Incumbent Product (recommends this): ${incumbentProduct === null || incumbentProduct === void 0 ? void 0 : incumbentProduct.properties.name} (${edge.start_node_id})`);\n    });\n\n    // Find products recommended by selected incumbent products (forward BI_RECOMMENDS)\n    const forwardRecommendationEdges = relationships.filter(rel => rel.type === 'BI_RECOMMENDS' && selectedProducts.some(p => p.id === rel.start_node_id));\n    forwardRecommendationEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const recommendedProduct = nodes.find(n => n.id === edge.end_node_id);\n      console.log(`  üì¶ ‚Üí Recommended Product: ${recommendedProduct === null || recommendedProduct === void 0 ? void 0 : recommendedProduct.properties.name} (${edge.end_node_id})`);\n    });\n\n    // Find companies owning these products (including incumbent products)\n    const ownershipEdges = relationships.filter(rel => rel.type === 'OWNS' && connectedNodeIds.has(rel.end_node_id));\n    ownershipEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const company = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`  üè¢ Company: ${company === null || company === void 0 ? void 0 : company.properties.name} (${edge.start_node_id})`);\n    });\n\n    // Find field consultants covering these companies\n    const companies = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node === null || node === void 0 ? void 0 : node.labels.includes('COMPANY');\n    });\n    const coverageEdges = relationships.filter(rel => rel.type === 'COVERS' && companies.includes(rel.end_node_id));\n    coverageEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const fieldConsultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`    üìã Field consultant: ${fieldConsultant === null || fieldConsultant === void 0 ? void 0 : fieldConsultant.properties.name} (${edge.start_node_id})`);\n    });\n\n    // Find consultants employing these field consultants\n    const fieldConsultants = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node === null || node === void 0 ? void 0 : node.labels.includes('FIELD_CONSULTANT');\n    });\n    const employmentEdges = relationships.filter(rel => rel.type === 'EMPLOYS' && fieldConsultants.includes(rel.end_node_id));\n    employmentEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const consultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`      üë®‚Äçüíº Consultant: ${consultant === null || consultant === void 0 ? void 0 : consultant.properties.name} (${edge.start_node_id})`);\n    });\n    return connectedNodeIds;\n  }\n  getIncumbentProductSubgraph(nodes, relationships, incumbentProductNames) {\n    const connectedNodeIds = new Set();\n    const selectedIncumbentProducts = nodes.filter(node => node.labels.includes('INCUMBENT_PRODUCT') && incumbentProductNames.includes(node.properties.name));\n\n    // Add selected incumbent products\n    selectedIncumbentProducts.forEach(product => {\n      connectedNodeIds.add(product.id);\n      console.log(`üéØ Selected incumbent product: ${product.properties.name} (${product.id})`);\n    });\n\n    // Find products recommended by these incumbent products\n    const recommendationEdges = relationships.filter(rel => rel.type === 'BI_RECOMMENDS' && selectedIncumbentProducts.some(p => p.id === rel.start_node_id));\n    recommendationEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const recommendedProduct = nodes.find(n => n.id === edge.end_node_id);\n      console.log(`  üì¶ ‚Üí Recommended Product: ${recommendedProduct === null || recommendedProduct === void 0 ? void 0 : recommendedProduct.properties.name} (${edge.end_node_id})`);\n    });\n\n    // Find companies owning these incumbent products\n    const ownershipEdges = relationships.filter(rel => rel.type === 'OWNS' && selectedIncumbentProducts.some(p => p.id === rel.end_node_id));\n    ownershipEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const company = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`  üè¢ Company: ${company === null || company === void 0 ? void 0 : company.properties.name} (${edge.start_node_id})`);\n    });\n\n    // Continue with standard path (field consultants, consultants)\n    const companies = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node === null || node === void 0 ? void 0 : node.labels.includes('COMPANY');\n    });\n    const coverageEdges = relationships.filter(rel => rel.type === 'COVERS' && companies.includes(rel.end_node_id));\n    coverageEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const fieldConsultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`    üìã Field consultant: ${fieldConsultant === null || fieldConsultant === void 0 ? void 0 : fieldConsultant.properties.name} (${edge.start_node_id})`);\n    });\n    const fieldConsultants = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node === null || node === void 0 ? void 0 : node.labels.includes('FIELD_CONSULTANT');\n    });\n    const employmentEdges = relationships.filter(rel => rel.type === 'EMPLOYS' && fieldConsultants.includes(rel.end_node_id));\n    employmentEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const consultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`      üë®‚Äçüíº Consultant: ${consultant === null || consultant === void 0 ? void 0 : consultant.properties.name} (${edge.start_node_id})`);\n    });\n    return connectedNodeIds;\n  }\n  extractFilterOptionsFromData(data) {\n    const options = {\n      regions: new Set(['NAI', 'EMEA', 'APAC']),\n      sales_regions: new Set(),\n      channels: new Set(),\n      assetClasses: new Set(),\n      consultants: new Set(),\n      fieldConsultants: new Set(),\n      clients: new Set(),\n      products: new Set(),\n      incumbent_products: new Set(),\n      pcas: new Set(),\n      acas: new Set(),\n      ratings: new Set(['Positive', 'Negative', 'Neutral', 'Introduced']),\n      mandateStatuses: new Set(['Active', 'At Risk', 'Conversion in Progress']),\n      jpm_flags: new Set(['Y', 'N']),\n      privacy_levels: new Set(['Public', 'Private', 'Confidential']),\n      influenceLevels: new Set(['1', '2', '3', '4'])\n    };\n    data.nodes.forEach(node => {\n      const props = node.properties;\n      if (props.sales_region) options.sales_regions.add(props.sales_region);\n      if (props.channel) options.channels.add(props.channel);\n      if (props.asset_class) options.assetClasses.add(props.asset_class);\n      if (props.pca) options.pcas.add(props.pca);\n      if (props.aca) options.acas.add(props.aca);\n      if (props.jpm_flag) options.jpm_flags.add(props.jpm_flag);\n      if (props.privacy) options.privacy_levels.add(props.privacy);\n      if (node.labels.includes('CONSULTANT') && props.name) {\n        options.consultants.add(props.name);\n      }\n      if (node.labels.includes('FIELD_CONSULTANT') && props.name) {\n        options.fieldConsultants.add(props.name);\n      }\n      if (node.labels.includes('COMPANY') && props.name) {\n        options.clients.add(props.name);\n      }\n      if (node.labels.includes('PRODUCT') && props.name) {\n        options.products.add(props.name);\n      }\n      if (node.labels.includes('INCUMBENT_PRODUCT') && props.name) {\n        options.incumbent_products.add(props.name);\n      }\n    });\n    data.relationships.forEach(rel => {\n      if (rel.type === 'RATES' && rel.properties.rankgroup) {\n        options.ratings.add(rel.properties.rankgroup);\n      }\n      if (rel.type === 'OWNS' && rel.properties.mandate_status) {\n        options.mandateStatuses.add(rel.properties.mandate_status);\n      }\n      if (rel.type === 'COVERS' && rel.properties.level_of_influence) {\n        options.influenceLevels.add(String(rel.properties.level_of_influence));\n      }\n    });\n    const result = {};\n    Object.entries(options).forEach(([key, set]) => {\n      result[key] = Array.from(set).sort();\n    });\n    console.log('‚úÖ Local filter options extracted:', {\n      regions: result.regions.length,\n      sales_regions: result.sales_regions.length,\n      channels: result.channels.length,\n      consultants: result.consultants.length,\n      products: result.products.length\n    });\n    return result;\n  }\n  getEmptyFilterOptions() {\n    return {\n      regions: ['NAI', 'EMEA', 'APAC'],\n      sales_regions: [],\n      channels: [],\n      assetClasses: [],\n      consultants: [],\n      fieldConsultants: [],\n      clients: [],\n      products: [],\n      incumbent_products: [],\n      pcas: [],\n      acas: [],\n      clientAdvisors: [],\n      // Company PCA + ACA combined\n      consultantAdvisors: [],\n      // Consultant PCA + Advisor combined\n      ratings: ['Positive', 'Negative', 'Neutral', 'Introduced'],\n      mandateStatuses: ['Active', 'At Risk', 'Conversion in Progress'],\n      jpm_flags: ['Y', 'N'],\n      privacy_levels: ['Public', 'Private', 'Confidential'],\n      influenceLevels: ['1', '2', '3', '4', 'UNK', 'High', 'medium', 'low']\n    };\n  }\n  clearCache() {\n    this.regionDataCache.clear();\n    this.filterOptionsCache.clear();\n    console.log('üßπ API service cache cleared');\n  }\n}\n_ApiNeo4jService = ApiNeo4jService;\nApiNeo4jService.instance = void 0;\nexport default ApiNeo4jService;","map":{"version":3,"names":["transformHierarchicalOptions","ApiNeo4jService","constructor","baseUrl","regionDataCache","Map","filterOptionsCache","process","env","NEXT_PUBLIC_API_URL","console","log","getInstance","instance","testConnection","response","fetch","data","json","status","database_connected","error","getDatabaseStats","ok","Error","statusText","stats","fallbackError","getAvailableRegions","regions","getRegionData","join","region","cacheKey","sort","has","get","hierarchicalData","success","nodes","graph_data","length","relationships","filterOptions","statistics","total_filter_options","transformedData","metadata","source","set","filter_options","message","changeRegion","newRegion","currentRegion","method","clear","getFilterOptionsFromData","_data$metadata","extractFilterOptionsFromData","getEmptyFilterOptions","applyFiltersToData","filters","_data$nodes","_data$relationships","_filters$clientAdviso","_filters$consultantAd","_filters$clientAdviso2","_filters$consultantAd2","_data$nodes2","_filteredData$nodes","_filters$clientAdviso3","_filters$consultantAd3","nodeCount","relationshipCount","clientAdvisorIds","consultantAdvisorIds","filteredData","applyAdvisorFilters","applyFiltersLocallyWithOrphanRemoval","originalNodes","filteredNodes","advisorFilterApplied","clientAdvisors","consultantAdvisors","totalNodes","totalRelationships","anchorNodeIds","Set","forEach","node","_node$labels","labels","includes","props","properties","companyPca","pca","companyAca","aca","add","id","name","_node$labels2","consultantPca","consultantAdvisor","consultant_advisor","size","relevantNodeIds","expandFromCompanies","expandFromConsultants","filter","filteredRelationships","rel","start_node_id","end_node_id","nodeTypeCounts","_node$labels3","label","advisor_filter_applied","client_advisors_selected","consultant_advisors_selected","original_node_count","filtered_node_count","anchor_nodes_found","subgraph_composition","nodeIds","companies","Array","from","_node$labels4","find","n","type","_product$properties","product","fieldConsultants","_fc$properties","fc","_consultant$propertie","consultant","consultants","_node$labels5","_fc$properties2","_company$properties","company","_product$properties2","nodeTypes","some","sales_regions","sales_region","channels","channel","focusedFiltering","consultantIds","connectedNodeIds","getConsultantSubgraph","clientIds","getCompanySubgraph","fieldConsultantIds","getFieldConsultantSubgraph","productIds","getProductSubgraph","map","mandateStatuses","mandate_status","influenceLevels","level_of_influence","String","incumbentProductIds","getIncumbentProductSubgraph","showInactive","r","beforeCount","result","originalNodeCount","originalRelationshipCount","filteredNodeCount","filteredRelationshipCount","filtersApplied","consultantNames","selectedConsultants","employmentEdges","c","edge","fieldConsultant","coverageEdges","ownershipEdges","recommendationEdges","recEdge","recommendedProduct","companyNames","selectedCompanies","fieldConsultantNames","selectedFieldConsultants","productNames","selectedProducts","reverseRecommendationEdges","p","incumbentProduct","forwardRecommendationEdges","incumbentProductNames","selectedIncumbentProducts","options","assetClasses","clients","products","incumbent_products","pcas","acas","ratings","jpm_flags","privacy_levels","asset_class","jpm_flag","privacy","rankgroup","Object","entries","key","clearCache","_ApiNeo4jService"],"sources":["/Users/prabhakarmudliyar/text-to-cypher-mui/frontend/src/components/services/ApiNeo4jService.ts"],"sourcesContent":["// services/ApiNeo4jService.ts - COMPLETE with orphan removal functionality\nimport { FilterCriteria, FilterOptions, transformHierarchicalOptions } from '../types/FitlerTypes';\n\ninterface Neo4jNode {\n  id: string;\n  labels: string[];\n  properties: Record<string, any>;\n}\n\ninterface Neo4jRelationship {\n  id: string;\n  type: string;\n  start_node_id: string;\n  end_node_id: string;\n  properties: Record<string, any>;\n}\n\ninterface Neo4jResult {\n  nodes: Neo4jNode[];\n  relationships: Neo4jRelationship[];\n  metadata?: Record<string, any>;\n}\n\ninterface HierarchicalResponse {\n  success: boolean;\n  data?: {\n    region: string;\n    graph_data: {\n      nodes: Neo4jNode[];\n      relationships: Neo4jRelationship[];\n    };\n    filter_options: Record<string, any>;\n    statistics: {\n      total_nodes: number;\n      total_relationships: number;\n      total_filter_options: number;\n    };\n  };\n  message?: string;\n  error?: string;\n}\n\nexport class ApiNeo4jService {\n  private static instance: ApiNeo4jService;\n  public readonly baseUrl: string;\n  private regionDataCache: Map<string, Neo4jResult> = new Map();\n  private filterOptionsCache: Map<string, FilterOptions> = new Map();\n  \n  private constructor() {\n    this.baseUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';\n    console.log(`üîå ApiNeo4jService initialized with base URL: ${this.baseUrl}`);\n  }\n  \n  static getInstance(): ApiNeo4jService {\n    if (!ApiNeo4jService.instance) {\n      ApiNeo4jService.instance = new ApiNeo4jService();\n    }\n    return ApiNeo4jService.instance;\n  }\n  \n  async testConnection(): Promise<boolean> {\n    try {\n      const response = await fetch(`${this.baseUrl}/health`);\n      const data = await response.json();\n      \n      console.log('üîç API Health Check:', data);\n      return data.status === 'healthy' && data.database_connected;\n    } catch (error) {\n      console.error('‚ùå API connection test failed:', error);\n      return false;\n    }\n  }\n\n  async getDatabaseStats(): Promise<any> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/v1/hierarchical/health`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const stats = await response.json();\n      console.log('üìä Hierarchical service stats retrieved:', stats);\n      \n      return stats;\n    } catch (error) {\n      console.error('‚ùå Failed to get database stats:', error);\n      // Fallback to regular stats endpoint\n      try {\n        const response = await fetch(`${this.baseUrl}/api/v1/graph/stats`);\n        if (response.ok) {\n          return await response.json();\n        }\n      } catch (fallbackError) {\n        console.error('‚ùå Fallback stats also failed:', fallbackError);\n      }\n      throw error;\n    }\n  }\n\n  async getAvailableRegions(): Promise<string[]> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/v1/hierarchical/regions`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      console.log('üåç Available regions:', data.regions);\n      \n      return data.regions || ['NAI', 'EMEA', 'APAC'];\n    } catch (error) {\n      console.error('‚ùå Failed to get available regions:', error);\n      return ['NAI', 'EMEA', 'APAC'];\n    }\n  }\n  \n  async getRegionData(regions: string[] = ['NAI']): Promise<Neo4jResult> {\n    console.log(`üåç Loading data for regions using hierarchical endpoint: ${regions.join(', ')}`);\n    \n    try {\n      const region = regions[0];\n      const cacheKey = regions.sort().join(',');\n      \n      if (this.regionDataCache.has(cacheKey)) {\n        console.log(`üìã Using cached data for ${cacheKey}`);\n        return this.regionDataCache.get(cacheKey)!;\n      }\n      \n      const response = await fetch(`${this.baseUrl}/api/v1/hierarchical/region/${region}/complete`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const hierarchicalData: HierarchicalResponse = await response.json();\n      \n      if (!hierarchicalData.success || !hierarchicalData.data) {\n        throw new Error(hierarchicalData.error || 'Failed to get hierarchical data');\n      }\n      \n      console.log(`‚úÖ Retrieved hierarchical data for ${region}:`, {\n        nodes: hierarchicalData.data.graph_data.nodes.length,\n        relationships: hierarchicalData.data.graph_data.relationships.length,\n        filterOptions: hierarchicalData.data.statistics.total_filter_options\n      });\n      \n      const transformedData: Neo4jResult = {\n        nodes: hierarchicalData.data.graph_data.nodes,\n        relationships: hierarchicalData.data.graph_data.relationships,\n        metadata: {\n          region: hierarchicalData.data.region,\n          statistics: hierarchicalData.data.statistics,\n          source: 'hierarchical_complete_workflow'\n        }\n      };\n      \n      this.filterOptionsCache.set(region, transformHierarchicalOptions(hierarchicalData.data.filter_options || {}));\n      this.regionDataCache.set(cacheKey, transformedData);\n      \n      return transformedData;\n      \n    } catch (error) {\n      console.error('‚ùå Failed to fetch region data:', error);\n      throw new Error(`Failed to fetch region data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  async changeRegion(newRegion: string, currentRegion?: string): Promise<Neo4jResult> {\n    console.log(`üîÑ Changing region from ${currentRegion || 'unknown'} to ${newRegion}`);\n    \n    try {\n      const response = await fetch(`${this.baseUrl}/api/v1/hierarchical/region/change/${newRegion}?current_region=${currentRegion || ''}`, {\n        method: 'PUT'\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const hierarchicalData: HierarchicalResponse = await response.json();\n      \n      if (!hierarchicalData.success || !hierarchicalData.data) {\n        throw new Error(hierarchicalData.error || 'Failed to change region');\n      }\n      \n      console.log(`‚úÖ Region changed to ${newRegion}:`, {\n        nodes: hierarchicalData.data.graph_data.nodes.length,\n        relationships: hierarchicalData.data.graph_data.relationships.length\n      });\n      \n      this.regionDataCache.clear();\n      \n      const transformedData: Neo4jResult = {\n        nodes: hierarchicalData.data.graph_data.nodes,\n        relationships: hierarchicalData.data.graph_data.relationships,\n        metadata: {\n          region: hierarchicalData.data.region,\n          statistics: hierarchicalData.data.statistics,\n          source: 'hierarchical_region_change'\n        }\n      };\n      \n      this.filterOptionsCache.set(newRegion, transformHierarchicalOptions(hierarchicalData.data.filter_options || {}));\n      this.regionDataCache.set(newRegion, transformedData);\n      \n      return transformedData;\n      \n    } catch (error) {\n      console.error('‚ùå Failed to change region:', error);\n      throw new Error(`Failed to change region: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n  \n  async getFilterOptionsFromData(data: Neo4jResult): Promise<FilterOptions> {\n    console.log('üìä Getting filter options from hierarchical data...');\n    \n    try {\n      const region = data.metadata?.region;\n      if (region && this.filterOptionsCache.has(region)) {\n        console.log(`üìã Using cached filter options for ${region}`);\n        return this.filterOptionsCache.get(region)!;\n      }\n      \n      return this.extractFilterOptionsFromData(data);\n      \n    } catch (error) {\n      console.error('‚ùå Failed to get filter options:', error);\n      return this.getEmptyFilterOptions();\n    }\n  }\n\n  // üÜï ENHANCED: Main filtering method with orphan removal\n    async applyFiltersToData(data: Neo4jResult, filters: FilterCriteria): Promise<Neo4jResult> {\n    console.log('üîç Enhanced applyFiltersToData with advisor filtering:', {\n      nodeCount: data.nodes?.length || 0,\n      relationshipCount: data.relationships?.length || 0,\n      clientAdvisorIds: filters.clientAdvisorIds?.length || 0,\n      consultantAdvisorIds: filters.consultantAdvisorIds?.length || 0\n    });\n\n    // üÜï STEP 1: Apply advisor filters FIRST (most selective)\n    let filteredData = { ...data };\n    \n    if (filters.clientAdvisorIds?.length || filters.consultantAdvisorIds?.length) {\n      console.log('üë• Applying advisor filters first...');\n      filteredData = this.applyAdvisorFilters(filteredData, filters);\n    }\n\n    // üÜï STEP 2: Apply existing filtering logic\n    filteredData = this.applyFiltersLocallyWithOrphanRemoval(filteredData, filters);\n\n    console.log('‚úÖ Enhanced filtering complete:', {\n      originalNodes: data.nodes?.length || 0,\n      filteredNodes: filteredData.nodes?.length || 0,\n      advisorFilterApplied: !!(filters.clientAdvisorIds?.length || filters.consultantAdvisorIds?.length)\n    });\n\n    return filteredData;\n  }\n\n    // üîß FIXED: Enhanced advisor filtering with CORRECT relationship directions\n  private applyAdvisorFilters(data: Neo4jResult, filters: FilterCriteria): Neo4jResult {\n    const nodes = data.nodes || [];\n    const relationships = data.relationships || [];\n    \n    const clientAdvisorIds = filters.clientAdvisorIds || [];\n    const consultantAdvisorIds = filters.consultantAdvisorIds || [];\n\n    console.log('üë• Applying FIXED advisor filters with correct relationship directions:', {\n      clientAdvisors: clientAdvisorIds.length,\n      consultantAdvisors: consultantAdvisorIds.length,\n      totalNodes: nodes.length,\n      totalRelationships: relationships.length\n    });\n\n    if (!clientAdvisorIds.length && !consultantAdvisorIds.length) {\n      return data;\n    }\n\n    // Step 1: Find anchor nodes (companies/consultants matching advisor criteria)\n    const anchorNodeIds = new Set<string>();\n\n    // Client Advisor filtering (Company PCA/ACA) - Find matching companies\n    if (clientAdvisorIds.length > 0) {\n      console.log('üè¢ Finding companies with Client Advisors:', clientAdvisorIds);\n      nodes.forEach((node: Neo4jNode) => {\n        if (node.labels?.includes('COMPANY')) {\n          const props = node.properties || {};\n          const companyPca = props.pca || '';\n          const companyAca = props.aca || '';\n          \n          if (clientAdvisorIds.includes(companyPca) || clientAdvisorIds.includes(companyAca)) {\n            anchorNodeIds.add(node.id);\n            console.log(`   ‚úÖ Company \"${props.name || node.id}\" matches (PCA: ${companyPca}, ACA: ${companyAca})`);\n          }\n        }\n      });\n    }\n\n    // Consultant Advisor filtering (Consultant PCA/Advisor) - Find matching consultants\n    if (consultantAdvisorIds.length > 0) {\n      console.log('üë®‚Äçüíº Finding consultants with Consultant Advisors:', consultantAdvisorIds);\n      nodes.forEach((node: Neo4jNode) => {\n        if (node.labels?.includes('CONSULTANT')) {\n          const props = node.properties || {};\n          const consultantPca = props.pca || '';\n          const consultantAdvisor = props.consultant_advisor || '';\n          \n          if (consultantAdvisorIds.includes(consultantPca) || consultantAdvisorIds.includes(consultantAdvisor)) {\n            anchorNodeIds.add(node.id);\n            console.log(`   ‚úÖ Consultant \"${props.name || node.id}\" matches (PCA: ${consultantPca}, Advisor: ${consultantAdvisor})`);\n          }\n        }\n      });\n    }\n\n    console.log(`üìä Found ${anchorNodeIds.size} anchor nodes (companies/consultants)`);\n\n    if (anchorNodeIds.size === 0) {\n      console.log('‚ùå No matching advisor nodes found');\n      return { ...data, nodes: [], relationships: [] };\n    }\n\n    // Step 2: CORRECTED - Build complete subgraph following correct relationship paths\n    const relevantNodeIds = new Set<string>(anchorNodeIds);\n\n    // üîß FIXED: Specific path expansion based on anchor type\n    if (clientAdvisorIds.length > 0) {\n      console.log('üè¢ Client Advisor path: Company ‚Üí Field Consultant ‚Üí Consultant ‚Üí Products');\n      this.expandFromCompanies(relevantNodeIds, nodes, relationships);\n    }\n\n    if (consultantAdvisorIds.length > 0) {\n      console.log('üë®‚Äçüíº Consultant Advisor path: Consultant ‚Üí Field Consultant ‚Üí Company ‚Üí Products');\n      this.expandFromConsultants(relevantNodeIds, nodes, relationships);\n    }\n\n    console.log(`‚úÖ Final expansion: ${relevantNodeIds.size} total nodes in subgraph`);\n\n    // Step 3: Filter nodes and relationships\n    const filteredNodes = nodes.filter((node: Neo4jNode) => relevantNodeIds.has(node.id));\n    const filteredRelationships = relationships.filter((rel: Neo4jRelationship) => \n      relevantNodeIds.has(rel.start_node_id) && relevantNodeIds.has(rel.end_node_id)\n    );\n\n    // Step 4: Debug output - show what types of nodes we got\n    const nodeTypeCounts: Record<string, number> = {};\n    filteredNodes.forEach(node => {\n      node.labels?.forEach(label => {\n        nodeTypeCounts[label] = (nodeTypeCounts[label] || 0) + 1;\n      });\n    });\n\n    console.log('üìà Filtered subgraph composition:', nodeTypeCounts);\n    console.log(`‚úÖ Advisor filtering result: ${filteredNodes.length} nodes, ${filteredRelationships.length} relationships`);\n\n    return {\n      ...data,\n      nodes: filteredNodes,\n      relationships: filteredRelationships,\n      metadata: {\n        ...data.metadata,\n        advisor_filter_applied: true,\n        client_advisors_selected: clientAdvisorIds.length,\n        consultant_advisors_selected: consultantAdvisorIds.length,\n        original_node_count: nodes.length,\n        filtered_node_count: filteredNodes.length,\n        anchor_nodes_found: anchorNodeIds.size,\n        subgraph_composition: nodeTypeCounts\n      }\n    };\n  }\n\n  // üÜï Helper: Expand from companies following: Company ‚Üê Field Consultant ‚Üê Consultant\n  private expandFromCompanies(nodeIds: Set<string>, nodes: Neo4jNode[], relationships: Neo4jRelationship[]): void {\n    const companies = Array.from(nodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node?.labels?.includes('COMPANY');\n    });\n\n    console.log(`üè¢ Expanding from ${companies.length} companies...`);\n\n    // Step 1: Company ‚Üí Products (OWNS relationship)\n    relationships.forEach(rel => {\n      if (rel.type === 'OWNS' && companies.includes(rel.start_node_id)) {\n        nodeIds.add(rel.end_node_id); // Add product\n        const product = nodes.find(n => n.id === rel.end_node_id);\n        console.log(`   üì¶ Added Product: ${product?.properties?.name || rel.end_node_id}`);\n      }\n    });\n\n    // Step 2: Company ‚Üê Field Consultant (COVERS relationship: FC -COVERS-> Company)\n    const fieldConsultants = new Set<string>();\n    relationships.forEach(rel => {\n      if (rel.type === 'COVERS' && companies.includes(rel.end_node_id)) {\n        nodeIds.add(rel.start_node_id); // Add field consultant\n        fieldConsultants.add(rel.start_node_id);\n        const fc = nodes.find(n => n.id === rel.start_node_id);\n        console.log(`   üë• Added Field Consultant: ${fc?.properties?.name || rel.start_node_id}`);\n      }\n    });\n\n    // Step 3: Field Consultant ‚Üê Consultant (EMPLOYS relationship: Consultant -EMPLOYS-> FC)\n    relationships.forEach(rel => {\n      if (rel.type === 'EMPLOYS' && fieldConsultants.has(rel.end_node_id)) {\n        nodeIds.add(rel.start_node_id); // Add consultant\n        const consultant = nodes.find(n => n.id === rel.start_node_id);\n        console.log(`   üë®‚Äçüíº Added Consultant: ${consultant?.properties?.name || rel.start_node_id}`);\n      }\n    });\n  }\n\n  // üÜï Helper: Expand from consultants following: Consultant ‚Üí Field Consultant ‚Üí Company ‚Üí Products\n  private expandFromConsultants(nodeIds: Set<string>, nodes: Neo4jNode[], relationships: Neo4jRelationship[]): void {\n    const consultants = Array.from(nodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node?.labels?.includes('CONSULTANT');\n    });\n\n    console.log(`üë®‚Äçüíº Expanding from ${consultants.length} consultants...`);\n\n    // Step 1: Consultant ‚Üí Field Consultant (EMPLOYS relationship)\n    const fieldConsultants = new Set<string>();\n    relationships.forEach(rel => {\n      if (rel.type === 'EMPLOYS' && consultants.includes(rel.start_node_id)) {\n        nodeIds.add(rel.end_node_id); // Add field consultant\n        fieldConsultants.add(rel.end_node_id);\n        const fc = nodes.find(n => n.id === rel.end_node_id);\n        console.log(`   üë• Added Field Consultant: ${fc?.properties?.name || rel.end_node_id}`);\n      }\n    });\n\n    // Step 2: Field Consultant ‚Üí Company (COVERS relationship)\n    const companies = new Set<string>();\n    relationships.forEach(rel => {\n      if (rel.type === 'COVERS' && fieldConsultants.has(rel.start_node_id)) {\n        nodeIds.add(rel.end_node_id); // Add company\n        companies.add(rel.end_node_id);\n        const company = nodes.find(n => n.id === rel.end_node_id);\n        console.log(`   üè¢ Added Company: ${company?.properties?.name || rel.end_node_id}`);\n      }\n    });\n\n    // Step 3: Company ‚Üí Products (OWNS relationship)\n    relationships.forEach(rel => {\n      if (rel.type === 'OWNS' && companies.has(rel.start_node_id)) {\n        nodeIds.add(rel.end_node_id); // Add product\n        const product = nodes.find(n => n.id === rel.end_node_id);\n        console.log(`   üì¶ Added Product: ${product?.properties?.name || rel.end_node_id}`);\n      }\n    });\n  }\n\n\n  // üÜï ENHANCED: Core filtering logic with smart orphan removal\n  private applyFiltersLocallyWithOrphanRemoval(data: Neo4jResult, filters: FilterCriteria): Neo4jResult {\n    let filteredNodes = [...data.nodes];\n    let filteredRelationships = [...data.relationships];\n    \n    console.log(`üîç Starting with ${filteredNodes.length} nodes, ${filteredRelationships.length} relationships`);\n    \n    // Step 1: Apply node type filters\n    if (filters.nodeTypes && filters.nodeTypes.length > 0) {\n      filteredNodes = filteredNodes.filter(node => \n        filters.nodeTypes!.some(type => node.labels.includes(type))\n      );\n      console.log(`üìä After node type filter: ${filteredNodes.length} nodes`);\n    }\n    \n    // Step 2: Apply geographic filters\n    if (filters.sales_regions && filters.sales_regions.length > 0) {\n      filteredNodes = filteredNodes.filter(node => \n        !node.properties.sales_region || filters.sales_regions!.includes(node.properties.sales_region)\n      );\n      console.log(`üåç After sales region filter: ${filteredNodes.length} nodes`);\n    }\n    \n    if (filters.channels && filters.channels.length > 0) {\n      filteredNodes = filteredNodes.filter(node => \n        !node.properties.channel || filters.channels!.includes(node.properties.channel)\n      );\n      console.log(`üì° After channel filter: ${filteredNodes.length} nodes`);\n    }\n    \n    // Step 3: Apply entity-specific filters (these create focused subgraphs)\n    let focusedFiltering = false;\n    \n    // üéØ CONSULTANT FILTERING with connected subgraph\n    if (filters.consultantIds && filters.consultantIds.length > 0) {\n      console.log(`üëî Filtering to specific consultants: ${filters.consultantIds.join(', ')}`);\n      focusedFiltering = true;\n      \n      const connectedNodeIds = this.getConsultantSubgraph(filteredNodes, filteredRelationships, filters.consultantIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After consultant subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n    \n    // üéØ COMPANY FILTERING with connected subgraph\n    if (filters.clientIds && filters.clientIds.length > 0) {\n      console.log(`üè¢ Filtering to specific companies: ${filters.clientIds.join(', ')}`);\n      focusedFiltering = true;\n      \n      const connectedNodeIds = this.getCompanySubgraph(filteredNodes, filteredRelationships, filters.clientIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After company subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n    \n    // üéØ FIELD CONSULTANT FILTERING with connected subgraph\n    if (filters.fieldConsultantIds && filters.fieldConsultantIds.length > 0) {\n      console.log(`üìã Filtering to specific field consultants: ${filters.fieldConsultantIds.join(', ')}`);\n      focusedFiltering = true;\n      \n      const connectedNodeIds = this.getFieldConsultantSubgraph(filteredNodes, filteredRelationships, filters.fieldConsultantIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After field consultant subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n    \n    // üéØ PRODUCT FILTERING with connected subgraph\n    if (filters.productIds && filters.productIds.length > 0) {\n      console.log(`üè¶ Filtering to specific products: ${filters.productIds.join(', ')}`);\n      focusedFiltering = true;\n      \n      const connectedNodeIds = this.getProductSubgraph(filteredNodes, filteredRelationships, filters.productIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After product subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n    \n    // Step 4: Filter relationships based on remaining nodes\n    const nodeIds = new Set(filteredNodes.map(n => n.id));\n    filteredRelationships = filteredRelationships.filter(rel => \n      nodeIds.has(rel.start_node_id) && nodeIds.has(rel.end_node_id)\n    );\n    console.log(`üîó After node filtering, relationships: ${filteredRelationships.length}`);\n    \n    // Step 5: Apply relationship-specific filters\n    if (filters.mandateStatuses && filters.mandateStatuses.length > 0) {\n      filteredRelationships = filteredRelationships.filter(rel => \n        rel.type !== 'OWNS' || \n        !rel.properties.mandate_status ||\n        filters.mandateStatuses!.includes(rel.properties.mandate_status)\n      );\n      console.log(`üìã After mandate status filter: ${filteredRelationships.length} relationships`);\n    }\n    \n    if (filters.influenceLevels && filters.influenceLevels.length > 0) {\n      filteredRelationships = filteredRelationships.filter(rel => \n        rel.type !== 'COVERS' || \n        !rel.properties.level_of_influence ||\n        filters.influenceLevels!.includes(String(rel.properties.level_of_influence))\n      );\n      console.log(`‚≠ê After influence level filter: ${filteredRelationships.length} relationships`);\n    }\n    // üÜï NEW: INCUMBENT PRODUCT FILTERING with connected subgraph\n    if (filters.incumbentProductIds && filters.incumbentProductIds.length > 0) {\n      console.log(`üéØ Filtering to specific incumbent products: ${filters.incumbentProductIds.join(', ')}`);\n      focusedFiltering = true;\n      \n      const connectedNodeIds = this.getIncumbentProductSubgraph(filteredNodes, filteredRelationships, filters.incumbentProductIds);\n      filteredNodes = filteredNodes.filter(node => connectedNodeIds.has(node.id));\n      console.log(`üîó After incumbent product subgraph filtering: ${filteredNodes.length} nodes`);\n    }\n\n    \n  console.log(`üîó After node filtering, relationships: ${filteredRelationships.length}`);\n    // Step 6: Final orphan removal (unless we did focused filtering)\n    if (!focusedFiltering && !filters.showInactive) {\n      const connectedNodeIds = new Set([\n        ...filteredRelationships.map(r => r.start_node_id),\n        ...filteredRelationships.map(r => r.end_node_id)\n      ]);\n      \n      const beforeCount = filteredNodes.length;\n      filteredNodes = filteredNodes.filter(node => \n        connectedNodeIds.has(node.id)\n      );\n      console.log(`üßπ Removed ${beforeCount - filteredNodes.length} orphaned nodes (showInactive=false)`);\n    }\n    \n    const result = { \n      nodes: filteredNodes, \n      relationships: filteredRelationships,\n      metadata: {\n        originalNodeCount: data.nodes.length,\n        originalRelationshipCount: data.relationships.length,\n        filteredNodeCount: filteredNodes.length,\n        filteredRelationshipCount: filteredRelationships.length,\n        filtersApplied: filters,\n        focusedFiltering: focusedFiltering\n      }\n    };\n    \n    console.log(`‚úÖ Final result: ${result.nodes.length} nodes, ${result.relationships.length} relationships`);\n    console.log(`üìä Filtering mode: ${focusedFiltering ? 'Focused Subgraph' : 'General Filtering'}`);\n    \n    return result;\n  }\n\n  // üÜï Helper method: Get consultant and connected subgraph\n  private getConsultantSubgraph(nodes: Neo4jNode[], relationships: Neo4jRelationship[], consultantNames: string[]): Set<string> {\n  const connectedNodeIds = new Set<string>();\n  \n  // Find selected consultants\n  const selectedConsultants = nodes.filter(node => \n    node.labels.includes('CONSULTANT') && \n    consultantNames.includes(node.properties.name)\n  );\n  \n  // Add selected consultants\n  selectedConsultants.forEach(consultant => {\n    connectedNodeIds.add(consultant.id);\n    console.log(`üéØ Selected consultant: ${consultant.properties.name} (${consultant.id})`);\n  });\n  \n  // Find field consultants employed by selected consultants\n  const employmentEdges = relationships.filter(rel => \n    rel.type === 'EMPLOYS' && \n    selectedConsultants.some(c => c.id === rel.start_node_id)\n  );\n  \n  employmentEdges.forEach(edge => {\n    connectedNodeIds.add(edge.end_node_id);\n    const fieldConsultant = nodes.find(n => n.id === edge.end_node_id);\n    console.log(`  üìã Field consultant: ${fieldConsultant?.properties.name} (${edge.end_node_id})`);\n  });\n  \n  // Find companies covered by these field consultants\n  const coverageEdges = relationships.filter(rel => \n    rel.type === 'COVERS' && \n    connectedNodeIds.has(rel.start_node_id)\n  );\n  \n  coverageEdges.forEach(edge => {\n    connectedNodeIds.add(edge.end_node_id);\n    const company = nodes.find(n => n.id === edge.end_node_id);\n    console.log(`    üè¢ Company: ${company?.properties.name} (${edge.end_node_id})`);\n  });\n  \n  // Find products owned by these companies (standard path)\n  const ownershipEdges = relationships.filter(rel => \n    rel.type === 'OWNS' && \n    connectedNodeIds.has(rel.start_node_id)\n  );\n  \n  ownershipEdges.forEach(edge => {\n    connectedNodeIds.add(edge.end_node_id);\n    const product = nodes.find(n => n.id === edge.end_node_id);\n    \n    // Check if this is an INCUMBENT_PRODUCT or regular PRODUCT\n    if (product?.labels.includes('INCUMBENT_PRODUCT')) {\n      console.log(`      üéØ Incumbent Product: ${product?.properties.name} (${edge.end_node_id})`);\n      \n      // üÜï NEW: Find products recommended by this incumbent product via BI_RECOMMENDS\n      const recommendationEdges = relationships.filter(rel => \n        rel.type === 'BI_RECOMMENDS' && \n        rel.start_node_id === edge.end_node_id\n      );\n      \n      recommendationEdges.forEach(recEdge => {\n        connectedNodeIds.add(recEdge.end_node_id);\n        const recommendedProduct = nodes.find(n => n.id === recEdge.end_node_id);\n        console.log(`        üì¶ ‚Üí Recommended Product: ${recommendedProduct?.properties.name} (${recEdge.end_node_id})`);\n      });\n      \n    } else if (product?.labels.includes('PRODUCT')) {\n      console.log(`      üì¶ Product: ${product?.properties.name} (${edge.end_node_id})`);\n    }\n  });\n  \n  return connectedNodeIds;\n}\n\n  // üÜï Helper method: Get company and connected subgraph\n  private getCompanySubgraph(nodes: Neo4jNode[], relationships: Neo4jRelationship[], companyNames: string[]): Set<string> {\n    const connectedNodeIds = new Set<string>();\n    \n    // Find selected companies\n    const selectedCompanies = nodes.filter(node => \n      node.labels.includes('COMPANY') && \n      companyNames.includes(node.properties.name)\n    );\n    \n    // Add selected companies\n    selectedCompanies.forEach(company => {\n      connectedNodeIds.add(company.id);\n      console.log(`üéØ Selected company: ${company.properties.name} (${company.id})`);\n    });\n    \n    // Find field consultants covering these companies\n    const coverageEdges = relationships.filter(rel => \n      rel.type === 'COVERS' && \n      selectedCompanies.some(c => c.id === rel.end_node_id)\n    );\n    \n    coverageEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const fieldConsultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`  üìã Field consultant: ${fieldConsultant?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    // Find consultants employing these field consultants\n    const employmentEdges = relationships.filter(rel => \n      rel.type === 'EMPLOYS' && \n      connectedNodeIds.has(rel.end_node_id)\n    );\n    \n    employmentEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const consultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`üë®‚Äçüíº Consultant: ${consultant?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    // Find products owned by selected companies\n    const ownershipEdges = relationships.filter(rel => \n      rel.type === 'OWNS' && \n      selectedCompanies.some(c => c.id === rel.start_node_id)\n    );\n    \n    ownershipEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const product = nodes.find(n => n.id === edge.end_node_id);\n      \n      // Check if this is an INCUMBENT_PRODUCT or regular PRODUCT\n      if (product?.labels.includes('INCUMBENT_PRODUCT')) {\n        console.log(`  üéØ Incumbent Product: ${product?.properties.name} (${edge.end_node_id})`);\n        \n        // üÜï NEW: Find products recommended by this incumbent product via BI_RECOMMENDS\n        const recommendationEdges = relationships.filter(rel => \n          rel.type === 'BI_RECOMMENDS' && \n          rel.start_node_id === edge.end_node_id\n        );\n        \n        recommendationEdges.forEach(recEdge => {\n          connectedNodeIds.add(recEdge.end_node_id);\n          const recommendedProduct = nodes.find(n => n.id === recEdge.end_node_id);\n          console.log(`    üì¶ ‚Üí Recommended Product: ${recommendedProduct?.properties.name} (${recEdge.end_node_id})`);\n        });\n        \n      } else if (product?.labels.includes('PRODUCT')) {\n        console.log(`  üì¶ Product: ${product?.properties.name} (${edge.end_node_id})`);\n      }\n    });\n    \n    return connectedNodeIds;\n  }\n\n  // üÜï Helper method: Get field consultant and connected subgraph\n  private getFieldConsultantSubgraph(nodes: Neo4jNode[], relationships: Neo4jRelationship[], fieldConsultantNames: string[]): Set<string> {\n    const connectedNodeIds = new Set<string>();\n    \n    const selectedFieldConsultants = nodes.filter(node => \n      node.labels.includes('FIELD_CONSULTANT') && \n      fieldConsultantNames.includes(node.properties.name)\n    );\n    \n    // Add selected field consultants\n    selectedFieldConsultants.forEach(fc => {\n      connectedNodeIds.add(fc.id);\n      console.log(`üéØ Selected field consultant: ${fc.properties.name} (${fc.id})`);\n    });\n    \n    // Find their parent consultants\n    const employmentEdges = relationships.filter(rel => \n      rel.type === 'EMPLOYS' && \n      selectedFieldConsultants.some(fc => fc.id === rel.end_node_id)\n    );\n    \n    employmentEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const consultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`üë®‚Äçüíº Consultant: ${consultant?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    // Find companies covered by selected field consultants\n    const coverageEdges = relationships.filter(rel => \n      rel.type === 'COVERS' && \n      selectedFieldConsultants.some(fc => fc.id === rel.start_node_id)\n    );\n    \n    coverageEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const company = nodes.find(n => n.id === edge.end_node_id);\n      console.log(`  üè¢ Company: ${company?.properties.name} (${edge.end_node_id})`);\n    });\n    \n    // Find products owned by covered companies\n    const companies = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node?.labels.includes('COMPANY');\n    });\n    \n    const ownershipEdges = relationships.filter(rel => \n      rel.type === 'OWNS' && companies.includes(rel.start_node_id)\n    );\n    \n    ownershipEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const product = nodes.find(n => n.id === edge.end_node_id);\n      \n      // üîß NEW: Check if this is an INCUMBENT_PRODUCT or regular PRODUCT\n      if (product?.labels.includes('INCUMBENT_PRODUCT')) {\n        console.log(`    üéØ Incumbent Product: ${product?.properties.name} (${edge.end_node_id})`);\n        \n        // üÜï NEW: Find products recommended by this incumbent product via BI_RECOMMENDS\n        const recommendationEdges = relationships.filter(rel => \n          rel.type === 'BI_RECOMMENDS' && \n          rel.start_node_id === edge.end_node_id\n        );\n        \n        recommendationEdges.forEach(recEdge => {\n          connectedNodeIds.add(recEdge.end_node_id);\n          const recommendedProduct = nodes.find(n => n.id === recEdge.end_node_id);\n          console.log(`      üì¶ ‚Üí Recommended Product: ${recommendedProduct?.properties.name} (${recEdge.end_node_id})`);\n        });\n        \n      } else if (product?.labels.includes('PRODUCT')) {\n        console.log(`    üì¶ Product: ${product?.properties.name} (${edge.end_node_id})`);\n      }\n    });\n    \n    return connectedNodeIds;\n  }\n\n  // üÜï Helper method: Get product and connected subgraph\n  private getProductSubgraph(nodes: Neo4jNode[], relationships: Neo4jRelationship[], productNames: string[]): Set<string> {\n    const connectedNodeIds = new Set<string>();\n    \n    const selectedProducts = nodes.filter(node => \n      (node.labels.includes('PRODUCT') || node.labels.includes('INCUMBENT_PRODUCT')) && \n      productNames.includes(node.properties.name)\n    );\n    \n    // Add selected products\n    selectedProducts.forEach(product => {\n      connectedNodeIds.add(product.id);\n      console.log(`üéØ Selected product: ${product.properties.name} (${product.id})`);\n    });\n    \n    // üÜï NEW: Handle BI_RECOMMENDS relationships for both directions\n    \n    // Find incumbent products that recommend selected products (reverse BI_RECOMMENDS)\n    const reverseRecommendationEdges = relationships.filter(rel => \n      rel.type === 'BI_RECOMMENDS' && \n      selectedProducts.some(p => p.id === rel.end_node_id)\n    );\n    \n    reverseRecommendationEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const incumbentProduct = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`  üéØ ‚Üê Incumbent Product (recommends this): ${incumbentProduct?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    // Find products recommended by selected incumbent products (forward BI_RECOMMENDS)\n    const forwardRecommendationEdges = relationships.filter(rel => \n      rel.type === 'BI_RECOMMENDS' && \n      selectedProducts.some(p => p.id === rel.start_node_id)\n    );\n    \n    forwardRecommendationEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const recommendedProduct = nodes.find(n => n.id === edge.end_node_id);\n      console.log(`  üì¶ ‚Üí Recommended Product: ${recommendedProduct?.properties.name} (${edge.end_node_id})`);\n    });\n    \n    // Find companies owning these products (including incumbent products)\n    const ownershipEdges = relationships.filter(rel => \n      rel.type === 'OWNS' && \n      connectedNodeIds.has(rel.end_node_id)\n    );\n    \n    ownershipEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const company = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`  üè¢ Company: ${company?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    // Find field consultants covering these companies\n    const companies = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node?.labels.includes('COMPANY');\n    });\n    \n    const coverageEdges = relationships.filter(rel => \n      rel.type === 'COVERS' && companies.includes(rel.end_node_id)\n    );\n    \n    coverageEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const fieldConsultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`    üìã Field consultant: ${fieldConsultant?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    // Find consultants employing these field consultants\n    const fieldConsultants = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node?.labels.includes('FIELD_CONSULTANT');\n    });\n    \n    const employmentEdges = relationships.filter(rel => \n      rel.type === 'EMPLOYS' && fieldConsultants.includes(rel.end_node_id)\n    );\n    \n    employmentEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const consultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`      üë®‚Äçüíº Consultant: ${consultant?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    return connectedNodeIds;\n  }\n  \n  private getIncumbentProductSubgraph(nodes: Neo4jNode[], relationships: Neo4jRelationship[], incumbentProductNames: string[]): Set<string> {\n    const connectedNodeIds = new Set<string>();\n    \n    const selectedIncumbentProducts = nodes.filter(node => \n      node.labels.includes('INCUMBENT_PRODUCT') && \n      incumbentProductNames.includes(node.properties.name)\n    );\n    \n    // Add selected incumbent products\n    selectedIncumbentProducts.forEach(product => {\n      connectedNodeIds.add(product.id);\n      console.log(`üéØ Selected incumbent product: ${product.properties.name} (${product.id})`);\n    });\n    \n    // Find products recommended by these incumbent products\n    const recommendationEdges = relationships.filter(rel => \n      rel.type === 'BI_RECOMMENDS' && \n      selectedIncumbentProducts.some(p => p.id === rel.start_node_id)\n    );\n    \n    recommendationEdges.forEach(edge => {\n      connectedNodeIds.add(edge.end_node_id);\n      const recommendedProduct = nodes.find(n => n.id === edge.end_node_id);\n      console.log(`  üì¶ ‚Üí Recommended Product: ${recommendedProduct?.properties.name} (${edge.end_node_id})`);\n    });\n    \n    // Find companies owning these incumbent products\n    const ownershipEdges = relationships.filter(rel => \n      rel.type === 'OWNS' && \n      selectedIncumbentProducts.some(p => p.id === rel.end_node_id)\n    );\n    \n    ownershipEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const company = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`  üè¢ Company: ${company?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    // Continue with standard path (field consultants, consultants)\n    const companies = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node?.labels.includes('COMPANY');\n    });\n    \n    const coverageEdges = relationships.filter(rel => \n      rel.type === 'COVERS' && companies.includes(rel.end_node_id)\n    );\n    \n    coverageEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const fieldConsultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`    üìã Field consultant: ${fieldConsultant?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    const fieldConsultants = Array.from(connectedNodeIds).filter(id => {\n      const node = nodes.find(n => n.id === id);\n      return node?.labels.includes('FIELD_CONSULTANT');\n    });\n    \n    const employmentEdges = relationships.filter(rel => \n      rel.type === 'EMPLOYS' && fieldConsultants.includes(rel.end_node_id)\n    );\n    \n    employmentEdges.forEach(edge => {\n      connectedNodeIds.add(edge.start_node_id);\n      const consultant = nodes.find(n => n.id === edge.start_node_id);\n      console.log(`      üë®‚Äçüíº Consultant: ${consultant?.properties.name} (${edge.start_node_id})`);\n    });\n    \n    return connectedNodeIds;\n  }\n  private extractFilterOptionsFromData(data: Neo4jResult): FilterOptions {\n    const options: Record<string, Set<string>> = {\n      regions: new Set(['NAI', 'EMEA', 'APAC']),\n      sales_regions: new Set(),\n      channels: new Set(),\n      assetClasses: new Set(),\n      consultants: new Set(),\n      fieldConsultants: new Set(),\n      clients: new Set(),\n      products: new Set(),\n      incumbent_products: new Set(),\n      pcas: new Set(),\n      acas: new Set(),\n      ratings: new Set(['Positive', 'Negative', 'Neutral', 'Introduced']),\n      mandateStatuses: new Set(['Active', 'At Risk', 'Conversion in Progress']),\n      jpm_flags: new Set(['Y', 'N']),\n      privacy_levels: new Set(['Public', 'Private', 'Confidential']),\n      influenceLevels: new Set(['1', '2', '3', '4'])\n    };\n    \n    data.nodes.forEach(node => {\n      const props = node.properties;\n      \n      if (props.sales_region) options.sales_regions.add(props.sales_region);\n      if (props.channel) options.channels.add(props.channel);\n      if (props.asset_class) options.assetClasses.add(props.asset_class);\n      if (props.pca) options.pcas.add(props.pca);\n      if (props.aca) options.acas.add(props.aca);\n      if (props.jpm_flag) options.jpm_flags.add(props.jpm_flag);\n      if (props.privacy) options.privacy_levels.add(props.privacy);\n      \n      if (node.labels.includes('CONSULTANT') && props.name) {\n        options.consultants.add(props.name);\n      }\n      if (node.labels.includes('FIELD_CONSULTANT') && props.name) {\n        options.fieldConsultants.add(props.name);\n      }\n      if (node.labels.includes('COMPANY') && props.name) {\n        options.clients.add(props.name);\n      }\n      if (node.labels.includes('PRODUCT') && props.name) {\n        options.products.add(props.name);\n      }\n      if (node.labels.includes('INCUMBENT_PRODUCT') && props.name) {\n        options.incumbent_products.add(props.name);\n      }\n    });\n    \n    data.relationships.forEach(rel => {\n      if (rel.type === 'RATES' && rel.properties.rankgroup) {\n        options.ratings.add(rel.properties.rankgroup);\n      }\n      if (rel.type === 'OWNS' && rel.properties.mandate_status) {\n        options.mandateStatuses.add(rel.properties.mandate_status);\n      }\n      if (rel.type === 'COVERS' && rel.properties.level_of_influence) {\n        options.influenceLevels.add(String(rel.properties.level_of_influence));\n      }\n    });\n    \n    const result: FilterOptions = {} as FilterOptions;\n    Object.entries(options).forEach(([key, set]) => {\n      result[key as keyof FilterOptions] = Array.from(set).sort() as any;\n    });\n    \n    console.log('‚úÖ Local filter options extracted:', {\n      regions: result.regions.length,\n      sales_regions: result.sales_regions.length,\n      channels: result.channels.length,\n      consultants: result.consultants.length,\n      products: result.products.length\n    });\n    \n    return result;\n  }\n  \n  private getEmptyFilterOptions(): FilterOptions {\n    return {\n      regions: ['NAI', 'EMEA', 'APAC'],\n      sales_regions: [],\n      channels: [],\n      assetClasses: [],\n      consultants: [],\n      fieldConsultants: [],\n      clients: [],\n      products: [],\n      incumbent_products: [],\n      pcas: [],\n      acas: [],\n      clientAdvisors: [], // Company PCA + ACA combined\n     consultantAdvisors: [], // Consultant PCA + Advisor combined\n      ratings: ['Positive', 'Negative', 'Neutral', 'Introduced'],\n      mandateStatuses: ['Active', 'At Risk', 'Conversion in Progress'],\n      jpm_flags: ['Y', 'N'],\n      privacy_levels: ['Public', 'Private', 'Confidential'],\n      influenceLevels: ['1', '2', '3', '4', 'UNK', 'High', 'medium', 'low'],\n    };\n  }\n  \n  clearCache(): void {\n    this.regionDataCache.clear();\n    this.filterOptionsCache.clear();\n    console.log('üßπ API service cache cleared');\n  }\n}\n\nexport default ApiNeo4jService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}